Scope Customization at the Resource Server for Fine-grained Access Control
*Michiel de Jong, Pieter van der Meulen (SURF)*

In Research and education (R&E), we see new standards evolving (e.g. in AARC https://aarc-project.eu) that address the use-cases that are particularly relevant in that environment, and that are not addressed by existing OAuth standards. This is linked to a move away from authentication mechanisms like passwords, SSH keys and X.509 certificates towards token based authentication. In R&E, we see that the organisations in control of the various resource servers and clients work together in communities. These communities run an authorization server and manage trust and authorization policies. In this context we see that the authorization server does not have detailed knowledge of the resources and access modes that a resource server can offer, and thus is not well-placed to present a scope selection GUI that goes beyond using a generic description of the scope. This is a problem for use-cases where more fine-grained control over the level of access is required. E.g. granting access to a specific folder on a storage server, or granting access to a specific computing resource and that cannot be solved by establishing a list of generic scopes. Another usecase that we want to address is where there are several resource servers that offer a similar service using the same protocol, e.g. storage servers that offer WebDAV access to files. In this case, the user should be able to choose the resource server that they want to access, and the client should not have to know about the resource servers in advance. We aim for a solution that does not require changes to existing resources servers, and that will work with existing OAuth clients. We expect that our solution will be of interest to other communities that have similar requirements, where the authorization server and resource server are developed by different entities.

We considered using the Lodging Intent Pattern, a "pre-dance" where the client first obtains a structured scope before initiating the main OAuth dance, but we rejected this approach because it creates an undesirable many-to-many relationship between clients and the specific resource servers. Instead, we want to hide the resource server behind the authorization server which acts as a trusted broker between the various clients of various the organisations and the various resource servers of various (other) organisations.

We therefore want to propose an OAuth extension which adds a "scope picker" service close to each resource server, to which the authorization server redirects the user in a "sub-dance", leaving the GUI of the authorization server generic and easy to maintain. This works as follows: using the standard authorization code flow, the client redirects the user to the authorization server. The client can request a specific resource server by including an audience, or it can use a scope to request a specific type of service (e.g. WebDAV). The authorization server then redirects the user to a well-known endpoint on the resource server's scope picker service based on the client's and user's preferences and applies any restrictions based on the communities' policy. The scope picker shows a GUI in which the user can select e.g. a folder and set the level from the ones they have access to and set the level of access (read, write) and builds a structured scope from this information. This structured scope is given a human-readable name, either suggested by the scope picker or chosen by the user. The scope picker then redirects the user back to the authorization server including all the scope information, which is then able to display the human-readable description in its GUI, even though the authorization server doesn't understand what it stands for. Optionally protocol specific information (e.g. the WebDAV URL to use) is returned to the authorization server, this is required because the client may not have knowledge about the resource server that the user selected. When the user then 'grants access' on the authorization server, the OAuth authorization code flow is continued back to the client as normal. The client can then use its access token to request the protocol specific information from the authorization server using a well-known endpoint on the authorization server and use it to access the resource server.

